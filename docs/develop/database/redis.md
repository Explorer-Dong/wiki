---
title: Redis
status: new
---

## Redis 是什么

Redis（Remote Dictionary Server）最初被设计为一个高性能的内存键值数据库，但在长期演进中，它已经成为分布式系统中的基础组件之一。它既不是传统意义上的数据库，也不是简单的缓存，而是一个以内存为核心、以数据结构为特色、以性能和灵活性著称的数据服务。

如果只用一句话概括：Redis 是一个**提供丰富数据结构、支持持久化和复制的内存数据引擎**。

## 为什么需要 Redis

### 内存与磁盘的性能鸿沟

现代系统中，CPU 与内存的速度远高于磁盘 I/O。即便使用 SSD，随机读写的延迟仍然在微秒级，而内存访问则在纳秒级。Redis 将热点数据直接放在内存中，绕过磁盘瓶颈，这是其性能优势的物理基础。

### 关系型数据库的结构性限制

关系型数据库擅长强一致性和复杂查询，但在以下场景中往往力不从心：

* 高频简单读写（计数、状态查询）
* 大量短生命周期数据
* 需要原子操作但不需要事务语义

Redis 提供了更轻量的模型，补足了这一空缺。

## Redis 的核心设计哲学

### 单线程事件循环

Redis 的执行模型长期以来是单线程的。这里的“单线程”并不是指只能使用一个 CPU 核，而是**命令执行路径上不存在多线程并发写共享数据结构的问题**。

* 所有命令按顺序执行
* 无锁数据结构
* 可预测的延迟模型

网络 I/O 通过事件驱动模型（epoll/kqueue）实现高并发连接，但数据操作始终串行化。

### 数据结构优先，而非 SQL

Redis 并不提供通用查询语言，而是围绕数据结构设计命令集。你不是在“查表”，而是在“操作结构”。

## Redis 支持的数据结构

### String：最基础也是最通用

String 是 Redis 的最小抽象单元，可以是：

* 文本
* 数字（支持原子自增）
* 二进制数据

```bash
SET counter 1
INCR counter
```

这类操作在高并发场景下非常常见，例如请求计数、限流、序列号生成。

### Hash：面向对象的自然映射

Hash 适合表示结构化对象。

```bash
HSET user:1 name "alice" age 20
HGETALL user:1
```

相比将对象序列化成 JSON 存入 String，Hash 在字段级别具有更好的可操作性。

### List / Set / ZSet：集合语义的差异化

* List：有序、可重复，适合队列、日志
* Set：无序、去重，适合集合运算
* ZSet：有序且可排序，适合排行榜、延迟队列

这些结构让 Redis 在业务建模上具备极强的表达力。

## 原子性与一致性模型

### 命令级原子性

Redis 的每条命令天然是原子的，这是单线程模型直接带来的结果。

```bash
INCR counter
```

不需要锁，也不会被打断。

### Lua 脚本：多操作原子化

当单条命令不足以表达业务逻辑时，可以使用 Lua 脚本。

```lua
if redis.call("GET", KEYS[1]) then
    return redis.call("INCR", KEYS[1])
end
```

Redis 会保证整个脚本在执行期间不被其他命令插入。

## 持久化机制

### RDB：快照式持久化

RDB 通过定期生成内存快照来实现持久化。

* 优点：文件紧凑，恢复快
* 缺点：可能丢失最近一次快照后的数据

### AOF：日志式持久化

AOF 记录每一条写命令。

* 优点：数据安全性高
* 缺点：文件体积大，恢复慢

实际生产中通常**RDB + AOF 混合使用**，在性能与可靠性之间取得平衡。

## 复制与高可用

### 主从复制

Redis 通过异步复制实现读扩展：

* Master 负责写
* Replica 负责读

复制以命令流的形式进行，Replica 重放写命令以保持一致。

### Sentinel：故障发现与切换

Sentinel 提供：

* 节点存活监测
* 主从切换
* 客户端重定向

它并不参与数据存储，而是充当“控制平面”。

## Redis Cluster 与分片

### 为什么需要分片

单机 Redis 受限于：

* 内存上限
* 单节点带宽

Cluster 通过哈希槽（16384 slots）将键空间分布到多个节点。

### 去中心化设计

Redis Cluster 没有中心节点，每个节点都维护槽位映射表，客户端可以直连目标节点。

## Redis 的典型使用场景

### 缓存

* Cache Aside 模式
* 热点数据加速
* 防止缓存击穿、雪崩

### 分布式协调

* 分布式锁（SET NX PX）
* Leader 选举
* 状态同步

### 消息与流处理

* List / Stream 作为轻量消息队列
* 延迟任务

## 使用 Redis 的边界意识

Redis 很强，但并不是万能的。

* 内存成本高
* 不适合复杂查询
* 强一致性依赖业务约束

将 Redis 视为“系统加速器”和“状态引擎”，而不是唯一的数据源，通常是更合理的定位。

## 总结

Redis 的价值不只在于“快”，而在于它通过精心设计的数据结构、原子语义和系统机制，为分布式系统提供了一套高效、可组合的基础能力。

在理解 Redis 时，与其把它当作一个缓存工具，不如把它看作一个**以内存为介质、以数据结构为接口的系统组件**。
