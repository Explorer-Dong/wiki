---
title: 应用层
---

![应用层](https://cdn.dwj601.cn/images/20250627114434059.png)

## 基本概念

为了向用户提供端到端的服务，应用层针对不同的服务类型及其特点制定了对应的应用层协议。针对不同应用层协议的功能，人们将其划分为了以下三种：

1. 基础设施类：例如域名系统 (Domain Name System, DNS)、动态主机配置协议 (Dynamic Host Configuration Protocol, DHCP)；
2. 应用架构类：
    - 客户端-服务器架构 (Client-Server, C/S)，例如远程登陆协议 (Telecommunication Network, TELNET)、电子邮件协议 (SMTP / POP3 / IMAP)、超文本传输协议 (HTTP)、文件传输协议 (File Transfer Protocol, FTP) 等；
    - 对等架构 (Peer-to-Peer, P2P)，即 P2P 协议；
    - 混合架构 (C/S & P2P)；
3. 网络管理类：简单网络管理协议 (Simple Network Management Protocol, SNMP)。

## DHCP 协议

每一个客户端在联网时都需要一个 IP 地址、子网掩码、默认路由器的 IP 地址、域名服务器的 IP 地址。这些信息通常存储在一个配置文件中，计算机在引导过程中可以对这个文件进行存取。

动态主机配置协议 (Dynamic Host Configuration Protocol, DHCP) 提供了自动获取上述信息的机制。具体地，DHCP 基于 C/S 架构，自动为主机分配 IP 地址及其他的重要参数，客户端端口默认 68，服务端端口默认 67，使用 UDP 协议进行传输。

![主机 A 广播发送「发现报文 DHCPDISCOVER」](https://cdn.dwj601.cn/images/20250628102710358.png)

![DHCP 服务器单播响应「提供报文 DHCPOFFER」](https://cdn.dwj601.cn/images/20250628102820234.png)

如上两图所示：

- 主机广播请求：主机 A 首先基于 MAC 地址向同一个局域网中的所有终端广播寻找 DHCP 服务器的地址，一般都是找路由器，当然路由器也可以继续使用 UDP 传输协议去互联网找对应的 DHCP 服务器地址；
- DHCP 服务器单播响应：DHCP 服务器收到 DHCPDISCOVER 之后就基于 ARP 协议根据 IP 地址找 MAC 地址把各种配置信息单播发送给主机 A，之后 A 就具备了上网的功能了。

## DNS 协议

为了解决 IP 地址难以记忆的问题，域名系统 (Domain Name System, DNS) 被设计了出来，其核心就是存储字符串（域名）到 IP 地址的映射。

这样的映射被存储在了全球各个域名服务器上，考虑到请求压力，域名服务器以分布式地方式进行组织，例如分为根域名服务器、顶级域名服务器、二级域名服务器、本地域名服务器等，用户在获取一个域名的 IP 地址时，应用进程首先在本地的 53 号端口封装 DNS 请求报文（基于 UDP 协议），然后基于 DNS 协议向本地域名服务器发起请求，本地域名服务器得到查询结果后，将对应 IP 地址放在应答报文中返回给应用进程。

查询方式有两种：

1. 递归查询：本地域名服务器如果没存储对应的域名 IP 映射，就以客户端的身份继续请求更高等级的域名服务器直到找到，然后逐层返回结果；
2. 迭代查询：本地域名服务器如果每存储对应的域名 IP 映射，就把更高一级的域名服务器 IP 返回应用进程，应用进程重复刚才的请求查询更高一级的域名服务器直到找到。这种方式也是目前流行的方式。

举一个查询的例子，如下图所示：

![一个查询的例子](https://cdn.dwj601.cn/images/20250628105323963.png)

在实际查询时，一般会优先选择距离最近的域名服务器，同时为了降低查询次数，各级域名服务器以及本地主机都会缓存一个域名到 IP 的映射（即 DNS 缓存）。例如我查询本地的 DNS 缓存：

![查询本地的 DNS 缓存](https://cdn.dwj601.cn/images/20250628110035606.png)

## FTP 协议

考虑到不同系统的文件组织方式不同，文件传输协议 (File Transfer Protocol, FTP) 被设计了出来。其核心思想就一个，利用从属进程完成可靠数据传输。

![FTP 文件传输示意图](https://cdn.dwj601.cn/images/20250628114519105.png)

如上图所示，解释了 FTP 协议的整个过程，具体地：

- FTP 服务器采用 C/S 架构，服务器持续在 21 端口上运行 FTP 控制进程，等待连接；
- FTP 客户端与服务器通过控制进程连接后，启用数据传输进程（与控制进程为从属关系）进行数据传输；
- 传输结束后服务器终止数据传输进程，保持控制进程。

当然从属进程的设计初衷是为了提升连接的并发性，同时也起到了资源隔离的作用。比如一个服务器可以使用一个控制进程快速连接多个客户端，而不会被缓慢的数据传输降低连接效率，同时如果一个传输进程崩溃了也不会影响到连接进程或者其他传输进程。

## TELNET 协议

为了进行远程登陆，远程登陆协议 (TELecommunication NETwork, TELNET) 被设计了出来。其核心概念是引入了网络虚拟终端 (Network Virtual Terminal, NVT)，NVT 定义了一组通用字符集，屏蔽了不同计算机系统对键盘输入差异性的同时，也定义了客户进程与远程服务器进程之间的交互过程，保证了不同硬件、软件与数据格式的终端与主机之间通信的兼容性。

与 FTP 协议类似，TELNET 同样使用 C/S 架构的 TCP 从属进程连接模式，服务器端默认启用 23 端口监听 TELNET 连接。后因为安全问题逐渐被 [SSH](#ssh-协议) 替代。

![TELNET 远程连接示意图](https://cdn.dwj601.cn/images/20250628160800281.png)

如上图所示，本地终端输入的字符首先由本地 TELNET 客户进程转换为 NVT 格式，通过网络将 NVT 格式的字符传输到远程主机，远程 TELNET 服务器进程再将 NVT 格式的字符转换为远程主机能够识别和处理的字符格式。

## SSH 协议

安全外壳协议 (Secure Shell Protocol, SSH) 是一种加密的网络传输协议，通过在网络中建立安全隧道来实现 SSH 客户端与服务器之间的连接，可在不安全的网络中为网络服务提供安全的传输环境。

SSH 最常见的用途是远程登录系统，人们通常利用 SSH 来传输命令行界面和远程执行命令，当然现在也常常用来作为文件传输的加密方法，例如 SCP 协议和后来的 SFTP 协议。

![TELNET vs SSH](https://cdn.dwj601.cn/images/20251017225826133.png)

## SCP 协议

安全复制协议 (Secure Copy Protocol, SCP) 是基于 SSH 的一种文件传输协议，它在安全的加密通道中实现文件的复制操作。

SCP 的设计理念非常简单，主要用于在本地与远程主机之间，或两台远程主机之间安全地传输文件。它在执行时直接调用 SSH 进行认证和加密，因此不需要额外的配置，也能保证数据传输过程中不会被窃听或篡改。

SCP 功能较为单一，无法像 FTP 那样浏览目录或断点续传，更多用于脚本化或一次性文件传输场景。

## SFTP 协议

安全文件传输协议 (SSH File Transfer Protocol / Secure File Transfer Protocol, SFTP) 同样建立在 SSH 之上，但它并不是简单地复制 SSH 的通道，而是定义了一套独立的、结构化的文件传输子系统。

SFTP 支持丰富的文件操作，包括目录遍历、断点续传、文件删除、权限修改和符号链接管理等。相比 SCP，SFTP 在交互性和稳定性上更强，常被用于长期维护的远程文件系统管理。

由于其协议设计更接近传统的 FTP，但又保留了 SSH 的安全性，SFTP 逐渐取代了 SCP，成为现代系统中更推荐的安全文件传输方式。

## HTTP 协议

为了更快速地响应小文件，超文本传输协议 (HyperText Transfer Protocol, HTTP) 被设计了出来。它以 [HTML](../../../develop/front-end/html.md) 作为统一内容载体，客户端基于解释器（如浏览器）解析并呈现给用户。HTTP 工作在应用层，传输层使用 TCP 协议，服务器默认监听 80 端口（HTTPS 为 443）。

HTTP 核心特性是无状态。服务器不会保存客户端的历史请求状态，每个请求都被视为相互独立。这样实现简单、易扩展、容错性好，但是同一客户端的重复请求会带来额外开销，实际工程中通常通过 Cookie 等机制在应用层模拟状态。

HTTP 协议通过「**请求-响应**」模式来完成信息传递，基本工作流程如下图所示：

![HTTP 基本工作流程](https://cdn.dwj601.cn/images/20250628162119647.png)


**HTTP 请求** 由「请求行、请求头、请求体（可选）」三部分组成。具体地：

- 请求行：由 [请求方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Methods)、资源路径和协议版本组成，用于描述对什么资源、做什么操作；
- 请求头：以键值对的形式描述元信息，例如目标主机、数据格式和认证信息等；
- 请求体：这是可选的，用于承载要提交的资源表示，在 GET 请求中通常不存在，在 POST / PUT / PATCH 中较为常见。

**HTTP 响应** 由「状态行、响应头、响应体」三部分组成，表示服务器对请求的处理结果。具体地：

- 状态行：包含协议版本、[状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status) 以及原因短语，用于快速表明请求结果；
- 响应头：同样以键值对的形式描述元信息，例如返回数据的类型、长度以及资源位置等；
- 响应体：返回新创建资源的表示，供客户端进一步使用。

=== "HTTP **请求** 示例"

    ```http
    # 请求行
    POST /users HTTP/1.1

    # 请求头
    Host: api.example.com
    Content-Type: application/json
    Authorization: Bearer eyJhbGciOi...
    Content-Length: 32

    # 请求体
    {
      "name": "Alice",
      "age": 18
    }
    ```

=== "HTTP **响应** 示例"

    ```http
    # 状态行
    HTTP/1.1 201 Created

    # 响应头
    Content-Type: application/json
    Content-Length: 58
    Location: /users/123

    # 响应体
    {
        "id": 123,
        "name": "Alice",
        "age": 18
    }
    ```

## WebSocket 协议

WebSocket 是一种基于 TCP 的 **全双工** 通信协议，从 HTTP 升级而来。它主要被用于 **在客户端和服务器之间建立持久连接**，解决 HTTP 在实时通信场景下的性能与语义不足。

在实时通信场景下，HTTP 协议通常只能采用轮询，这种方案存在明显问题：大量无效请求、服务器压力大、延迟不可控。WebSocket 应运而生，它无请求-响应限制，一旦连接建立，客户端和服务器可以随时主动发送数据。这减少了 TCP 连接建立和 HTTP 头部重复传输的成本，实时性强、延迟低。

形式上，客户端首先以普通 HTTP 请求向服务器发起连接，在请求头中声明 `Upgrade: websocket`，表达希望将当前连接切换为 WebSocket 协议。服务器校验请求后，返回状态码 `101 Switching Protocols`，表示同意升级，此时这条连接从 HTTP 请求-响应模型切换为 WebSocket 的双向通信模型。双方不再发送 HTTP 报文，而是基于 WebSocket Frame 进行通信。数据以二进制帧的形式在同一条连接中双向流动，既可以是文本消息，也可以是任意二进制数据。

=== "WebSocket **请求** 示例"

    ```http
    # HTTP 请求行
    GET /chat HTTP/1.1

    # HTTP 请求头
    Host: example.com
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Key: xxx
    Sec-WebSocket-Version: 13
    ```

=== "WebSocket **响应** 示例"

    ```http
    # HTTP 状态行
    HTTP/1.1 101 Switching Protocols

    # HTTP 响应头
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: yyy
    ```

!!! tip "HTTP vs. WebSocket"

    从通信模型上看，HTTP 是典型的请求-响应协议，连接可以是短暂的，也可以通过 Keep-Alive 复用，但服务器始终只能被动响应客户端请求；而 WebSocket 是长连接的全双工协议，连接建立后双方地位对等，服务器可以主动推送数据，协议头开销也更小，因此实时性更强。

    在工程实践中，二者通常协同使用而非相互替代：

    - HTTP 负责资源型接口与控制类操作，例如登录鉴权、配置下发、REST API；
    - WebSocket 则作为持续存在的数据通道，用于承载实时消息、状态变更或事件流。

    例如，客户端先通过 HTTP 获取访问凭证并完成鉴权，再使用同一凭证建立 WebSocket 连接，用于接收实时通知或推送数据。这种分工能够同时兼顾系统的可维护性与高实时性。

## SMTP / POP / IMAP 协议

为了提供通信功能，电子邮件协议被设计了出来。与 HTTP 请求-响应的及时通信模型不同，电子邮件是基于存储-转发的异步架构进行的。因此一个电子邮件的系统主要由用户代理和消息传输代理两部分组成：

- 用户代理 (User Agent, UA)，又称为邮件代理。实现编辑、发送、阅读和管理电子邮件，通过 SMTP 协议和 MIME 扩展来完成；
- 传输代理 (Message Transfer Agent, MTA)，又称为邮件服务器。起“邮局”作用，实现接收用户邮件，根据邮件目的地址传送到接收方的邮件服务器，并将邮件存放在用户邮箱内，通过 POP 协议或 IMAP 协议来完成。

![电子邮件的通信过程](https://cdn.dwj601.cn/images/20250620101447242.png)

电子邮件的通信过程如上图所示，具体地：

1. 发送方利用邮件客户端（如 Outlook）撰写信件；
2. 用户代理程序将邮件通过 SMTP 协议发给邮件服务器；
3. 邮件服务器利用 SMTP 协议在邮件服务器之间传递邮件；
4. 邮件到达目的邮件服务器，目的邮件服务器将邮件放入接收方的信箱中；
5. 接收方利用 POP3 协议或 IMAP4 协议从邮件服务器中取信，并利用邮件客户端阅读信件。

简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是目前互联网上通用的电子邮件传输协议。采用 TCP 连接，服务端口为 25。SMTP 协议主要定义了邮件格式以及邮件服务器之间如何通过 TCP 连接进行邮件的传输。邮件服务器之间采用存储-转发的工作方式，某个邮件服务器收到一封邮件时，它产生一个副本，然后尽可能地将它转发出去。邮件服务器在下一个邮件服务器确认已经收到它转发的邮件后将副本删去。

由于 SMTP 协议只能支持文本的传输，不能再满足电子邮件日益增长的功能需求，所以之后开发出多用途互联网邮件扩充 (Multipurpose Internet Mail Extensions, MIME) 作为 SMTP 的扩展来弥补 SMTP 协议的不足（注意 MIME 本身并不是邮件传输协议）。MIME 增加了对图像、声音、视频、可执行文件等数据类型的支持，具体地：

- 发件方：MIME 将非文本内容转为 Base64 编码，并添加 `Content-Type` 等头部信息；SMTP 协议将 MIME 格式化后的文本传递给邮件服务器；
- 收件方：SMTP 服务器将邮件传递给收件人邮箱。邮件客户端解析 MIME 格式，还原出原始附件和正文。

邮局协议 (Post Office Protocol, POP) 是一个简单的邮件读取协议。由于用户代理和邮箱可能不在同一计算机上，所以用户代理需要和邮件服务器建立连接，将邮件从邮件服务器读取到本地。POP 协议在此过程中需要对用户的登录名和口令进行验证。目前常用的是 POP3 协议，同样采用 TCP 连接，服务端口为 110。POP 协议支持离线访问方式，即一次性全部下载邮件，也支持保留模式和删除模式两种工作模式。

互联网消息访问协议 (Internet Message Access Protocol, IMAP) 的功能与 POP 协议相似， 区别在于 POP3 协议是在脱机状态下运行，而 IMAP 协议是在联机状态下运行。IMAP 协议能够分步骤地下载用户邮件，同时在电子邮件服务器中保留副本。
